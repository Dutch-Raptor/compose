#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum SyntaxKind {
    Amp,
    AmpAmp,
    AmpersandEq,
    Apostrophe,
    Args,
    Arrow,
    AsKW,
    Assignment,
    At,
    Backtick,
    Bang,
    BangEq,
    Binary,
    Bool,
    BreakKW,
    Capture,
    CaptureList,
    CodeBlock,
    Colon,
    ColonColon,
    Comma,
    Comment,
    Condition,
    Conditional,
    ConditionalAlternate,
    ConditionalElse,
    ContinueKW,
    DestructureAssignment,
    Destructuring,
    DocComment,
    Dollar,
    Dot,
    Dots,
    DotsEq,
    DoubleQuote,
    Ellipsis,
    ElseKW,
    End,
    EnumKW,
    Eq,
    EqEq,
    Error,
    FieldAccess,
    Float,
    ForKW,
    ForLoop,
    FuncCall,
    Gt,
    GtEq,
    GtGt,
    Hash,
    Hat,
    HatEq,
    Ident,
    IfKW,
    ImportKW,
    InKW,
    IndexAccess,
    Int,
    LeftBrace,
    LeftBracket,
    LeftParen,
    LetKW,
    LetBinding,
    LoopKW,
    Lt,
    LtEq,
    LtLt,
    Minus,
    MinusEq,
    MutKW,
    Named,
    NewLine,
    Param,
    Params,
    Parenthesized,
    PathAccess,
    Percent,
    Pipe,
    PipeEq,
    PipePipe,
    Plus,
    PlusEq,
    PubKW,
    RefKW,
    ReturnKW,
    RightBrace,
    RightBracket,
    RightParen,
    Semicolon,
    Slash,
    SlashEq,
    Star,
    StarEq,
    Str,
    Tilde,
    TildeEq,
    Unary,
    Underscore,
    Unit,
    WhileKW,
    WhileLoop,
    Array,
    Range,
    MapLiteral,
    MapEntry,
    MatchKW,
    BreakStatement,
    ReturnStatement,
    Lambda,
    ImportItem,
    ModuleImport,
    Spread,
    ContinueStatement,
    MatchArm,
    MatchExpression,
    IsKW,
    TypedPattern,
    IsExpression,
}

impl SyntaxKind {
    pub(crate) fn is_terminator(&self) -> bool {
        matches!(
            self,
            Self::End | Self::Semicolon | Self::RightBrace | Self::RightParen | Self::RightBracket
        )
    }

    pub(crate) fn descriptive_name(&self) -> &'static str {
        match self { SyntaxKind::Amp => "&",
            SyntaxKind::AmpAmp => "&&",
            SyntaxKind::AmpersandEq => "&=",
            SyntaxKind::Apostrophe => "'",
            SyntaxKind::Args => "argument list",
            SyntaxKind::Array => "array",
            SyntaxKind::Arrow => "=>",
            SyntaxKind::AsKW => "as",
            SyntaxKind::Assignment => "assignment",
            SyntaxKind::At => "@",
            SyntaxKind::Backtick => "`",
            SyntaxKind::Bang => "!",
            SyntaxKind::BangEq => "!=",
            SyntaxKind::Binary => "binary expression",
            SyntaxKind::Bool => "boolean literal",
            SyntaxKind::BreakKW => "break",
            SyntaxKind::BreakStatement => "break statement",
            SyntaxKind::CaptureList => "capture group",
            SyntaxKind::Capture => "captured variable",
            SyntaxKind::CodeBlock => "code block",
            SyntaxKind::Colon => ":",
            SyntaxKind::ColonColon => "::",
            SyntaxKind::Comma => ",",
            SyntaxKind::Comment => "comment",
            SyntaxKind::Condition => "condition",
            SyntaxKind::Conditional => "if expression",
            SyntaxKind::ConditionalAlternate => "else if expression",
            SyntaxKind::ConditionalElse => "else expression",
            SyntaxKind::ContinueKW => "continue",
            SyntaxKind::ContinueStatement => "continue statement",
            SyntaxKind::DestructureAssignment => "destructuring assignment",
            SyntaxKind::Destructuring => "destructuring",
            SyntaxKind::DocComment => "doc comment",
            SyntaxKind::Dollar => "$",
            SyntaxKind::Dot => ".",
            SyntaxKind::Dots => "..",
            SyntaxKind::DotsEq => "..=",
            SyntaxKind::DoubleQuote => "\"",
            SyntaxKind::Ellipsis => "...",
            SyntaxKind::ElseKW => "else",
            SyntaxKind::End => "end of file",
            SyntaxKind::EnumKW => "enum",
            SyntaxKind::Eq => "=",
            SyntaxKind::EqEq => "==",
            SyntaxKind::Error => "error",
            SyntaxKind::FieldAccess => "field access",
            SyntaxKind::Float => "float literal",
            SyntaxKind::ForKW => "for",
            SyntaxKind::ForLoop => "for loop",
            SyntaxKind::FuncCall => "function call",
            SyntaxKind::Gt => ">",
            SyntaxKind::GtEq => ">=",
            SyntaxKind::GtGt => ">>",
            SyntaxKind::Hash => "#",
            SyntaxKind::Hat => "^",
            SyntaxKind::HatEq => "^=",
            SyntaxKind::Ident => "identifier",
            SyntaxKind::IfKW => "if",
            SyntaxKind::ImportKW => "import",
            SyntaxKind::InKW => "in",
            SyntaxKind::IndexAccess => "index access",
            SyntaxKind::Int => "integer literal",
            SyntaxKind::IsKW => "is",
            SyntaxKind::IsExpression => "is expression",
            SyntaxKind::LeftBrace => "{",
            SyntaxKind::LeftBracket => "[",
            SyntaxKind::LeftParen => "(",
            SyntaxKind::LetKW => "let",
            SyntaxKind::LetBinding => "let binding",
            SyntaxKind::LoopKW => "loop",
            SyntaxKind::Lt => "<",
            SyntaxKind::LtEq => "<=",
            SyntaxKind::LtLt => "<<",
            SyntaxKind::MapEntry => "map entry",
            SyntaxKind::MapLiteral => "map literal",
            SyntaxKind::Minus => "-",
            SyntaxKind::MinusEq => "-=",
            SyntaxKind::ModuleImport => "module import",
            SyntaxKind::ImportItem => "import item",
            SyntaxKind::MutKW => "mut",
            SyntaxKind::Named => "named binding",
            SyntaxKind::NewLine => "newline",
            SyntaxKind::Param => "parameter",
            SyntaxKind::Params => "parameter list",
            SyntaxKind::Parenthesized => "parenthesized expression",
            SyntaxKind::PathAccess => "path",
            SyntaxKind::Percent => "%",
            SyntaxKind::Pipe => "|",
            SyntaxKind::PipeEq => "|=",
            SyntaxKind::PipePipe => "||",
            SyntaxKind::Plus => "+",
            SyntaxKind::PlusEq => "+=",
            SyntaxKind::PubKW => "pub",
            SyntaxKind::Range => "range",
            SyntaxKind::RefKW => "ref",
            SyntaxKind::ReturnKW => "return",
            SyntaxKind::ReturnStatement => "return statement",
            SyntaxKind::RightBrace => "}",
            SyntaxKind::RightBracket => "]",
            SyntaxKind::RightParen => ")",
            SyntaxKind::Semicolon => ";",
            SyntaxKind::Slash => "/",
            SyntaxKind::SlashEq => "/=",
            SyntaxKind::Spread => "..",
            SyntaxKind::Star => "*",
            SyntaxKind::StarEq => "*=",
            SyntaxKind::Str => "string literal",
            SyntaxKind::Tilde => "~",
            SyntaxKind::TildeEq => "~=",
            SyntaxKind::Lambda => "trailing lambda",
            SyntaxKind::Unary => "unary expression",
            SyntaxKind::Underscore => "_",
            SyntaxKind::Unit => "()",
            SyntaxKind::WhileKW => "while",
            SyntaxKind::WhileLoop => "while loop",
            SyntaxKind::MatchKW => "match",
            SyntaxKind::MatchArm => "match arm",
            SyntaxKind::MatchExpression => "match expression",
            SyntaxKind::TypedPattern => "type binding pattern",
        }
    }

    pub(crate) fn matching_delimiter(&self) -> Option<SyntaxKind> {
        match self {
            Self::LeftBrace => Some(Self::RightBrace),
            Self::LeftParen => Some(Self::RightParen),
            Self::LeftBracket => Some(Self::RightBracket),
            Self::RightBrace => Some(Self::LeftBrace),
            Self::RightParen => Some(Self::LeftParen),
            Self::RightBracket => Some(Self::LeftBracket),
            Self::Pipe => Some(Self::Pipe),
            _ => None,
        }
    }

    pub(crate) fn is_closing_delimiter(&self) -> bool {
        matches!(
            self,
            Self::RightBrace | Self::RightParen | Self::RightBracket
        )
    }

    pub(crate) fn is_grouping(&self) -> bool {
        matches!(
            self,
            Self::LeftParen
                | Self::LeftBrace
                | Self::LeftBracket
                | Self::RightBrace
                | Self::RightParen
                | Self::RightBracket
                | Self::Pipe
        )
    }
    pub(crate) fn is_keyword(&self) -> bool {
        matches!(
            self,
            Self::AsKW
                | Self::BreakKW
                | Self::ContinueKW
                | Self::ElseKW
                | Self::EnumKW
                | Self::ForKW
                | Self::IfKW
                | Self::ImportKW
                | Self::InKW
                | Self::LetKW
                | Self::LetBinding
                | Self::LoopKW
                | Self::MutKW
                | Self::RefKW
                | Self::ReturnKW
                | Self::Unit
                | Self::WhileKW
                | Self::PubKW
                | Self::MatchKW
        )
    }
}
