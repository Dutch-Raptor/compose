use compose_doc_macros::compose_doc;

compose_doc! {
    /**
    # 🌍 Overview
    
    ## 🧱 Statements in Compose

    In Compose, programs are made up of **statements** each one representing a unit of execution. Statements can define variables, modify variables, or perform computations

    Let’s look at the different types of statements Compose supports:

    ---

    ### 1. **Expression Statement**

    If you write an expression on its own, it’s treated as a statement. Useful for side effects:

    ```compose
    3 + 4;      // evaluates to 7, but does nothing with it
    println("hi"); // prints "hi"
    ```

    Output:

    ```output stdout
    // autogenerated
    ```


    > Statements are always terminated with a semicolon.

    ---

    ### 2. **Let Binding**

    To introduce a new variable, use a `let` statement:

    ```compose
    let x = 42;
    let name = "Compose";
    ```

    Let-bindings are **immutable by default**. Once assigned, the value cannot be changed. Compose encourages you to write code that avoids accidental mutation.

    To declare a mutable variable, use `let mut`:

    ```compose
    let mut x = 42;
    x = 43
    ```
    

    ---

    ### 3. **Assignment**

    Assignments are statements that modify the value of an existing variable.

    ```compose
    let mut x = 42;
    x = 43;         // OK: `x` is mutable
    ```

    #### Modifying an immutable variable results in an error:

    ```compose error(E0004)
    let x = 1;
    x = 2;
    ```

    Error:

    ```output error(E0004)
    // autogenerated
    ```

    #### Assigning to an undeclared variable results in an error:

    ```compose error(E0011)
    y = 4;
    ```

    Error:

    ```output error(E0011)
    // autogenerated
    ```

    > Assignment always targets an existing variable. Compose will give you a helpful error if you try to assign to something undeclared or immutable.

    ---

    ## ✨ Expressions in Compose

    In Compose, *nearly everything is an expression*.

    An **expression** is anything that produces a value. This makes expressions the building blocks of the language. You can use them in assignments, as arguments to functions, in conditionals, or simply by themselves.

    Unlike some languages that separate "statements" and "expressions", Compose makes most constructs expressions—including control flow and blocks—so you can write more flexible and composable code.

    Let’s build up from the basics to more powerful forms.

    ---

    ### 1️⃣ Literals and Variables

    The simplest expressions are **literals** and **variable references**:

    ```compose
    42;            // number literal
    true;          // boolean literal
    "hello";       // string literal

    let x = 10;
    x;             // variable reference
    ```

    ---

    ### 2️⃣ Arithmetic and Logical Operators

    Compose supports standard operations on values:

    ```compose
    # let x = 1;
    # let y = 2;
    # let z = 3;
    1 + 2 * 3;
    x - 4;
    !true;
    x > 5 && y != 0;
    ```

    Operators follow conventional precedence (e.g. multiplication before addition) and can be grouped with parentheses.

    ---

    ### 3️⃣ Function Calls

    Functions and closures are called like this:

    ```compose
    # let add = (x, y) => x + y;
    print("hi");
    add(1, 2);
    ```

    Output:

    ```output stdout
    // autogenerated
    ```

    ---

    ### 4️⃣ Blocks as Expressions

    Curly-brace blocks `{ ... }` let you group multiple expressions. A block **returns the value of its last expression**.

    ```compose
    let result = {
        let y = 3;
        y + 1;     // returns 4
    };
    assert::eq(result, 4);
    ```

    This makes blocks ideal for introducing temporary variables or conditionally computing a value.

    ---

    ### 5️⃣ `if` Expressions

    Conditionals in Compose are expressions that produce a value:

    ```compose
    let a = 15;
    let x = if a > 10 {
        "big";
    } else {
        "small";
    };
    assert::eq(x, "big");
    ```

    Each branch must return a value of the same type, unless a branch ends in `break`, `return`, or an error.

    ---

    ### 6️⃣ Loops as Expressions

    Both `while` and `for` loops can also be used as expressions. You can return a value from a loop using `break`:

    ```compose
    // let result = {
    //     let mut i = 0;
    //     while true {
    //         if i == 5 {
    //             break i * 2; // returns 10
    //         };
    //         i = i + 1;
    //     };
    // };
    // assert::eq(result, 10);
    ```

    If no `break` with value occurs, the result of the loop is `unit`.

    ---

    ### 7️⃣ Closures and Anonymous Functions

    Closures are expressions too. You can assign them, pass them, or immediately call them:

    ```compose
    let double = (x) => x * 2;
    let result = double(5);     // 10
    assert::eq(result, 10);
    ```

    Closures can capture variables by reference if those variables are boxed:

    ```compose
    let mut b = box::new(3);
    let get = |ref b| () => *b;            // captures `b` by reference
    assert::eq(get(), 3);
    *b = 6;
    assert::eq(get(), 6); // get() returns the updated value of `b`
    ```

    Closures are first-class values and compose naturally with the rest of the language.

    ---

    ### Summary
    
    | Expression Type | Produces a value?  | Example                            |
    | ------------------ | -----------------  | ---------------------------------- |
    | Literal            | ✅                 | `42`, `"hi"`                       |
    | Variable reference | ✅                 | `x`                                |
    | Arithmetic         | ✅                 | `1 + 2 * 3`                        |
    | Function call      | ✅                 | `add(1, 2)`                        |
    | Block `{ ... }`    | ✅                 | `{ let x = 2; x + 1 }`             |
    | `if`/`else`        | ✅                 | `if x > 0 { "yes" } else { "no" }` |
    | `while` / `for`    | ✅ via `break`     | `while cond { break 5; }`          |
    | Closure            | ✅                 | `(x) => x + 1`                     |

    In Compose, the idea is simple: **if it does something, it probably returns something too.**
    
    ---
    
    | [Back](crate::docs) | [Next: Variables and scopes](crate::docs::C2_Variables_and_Scopes) |

    */
    pub mod C1_Overview {}
}
