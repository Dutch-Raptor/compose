use compose_doc_macros::compose_doc;

compose_doc!(
    /**
    ## 🧩 Variables, Let Bindings, and Scoping

    Variables in Compose are introduced using the `let` keyword. Every variable has a *scope*—the region of code where it is visible—and Compose is designed to make variable behavior clear and predictable.

    ### 📌 Let Bindings

    To bind a value to a name, use `let`:

    ```compose
    let x = 10;
    let name = "Compose";
    ```

    By default, variables are **immutable**—once assigned, they cannot be changed:

    ```compose error(E0004)
    let x = 5;
    x = 6; // ❌ Error: cannot assign to immutable variable
    ```

    ```output error(E0004)
    // autogenerated
    ```

    If you want to change the value later, use `let mut` to make the variable mutable:

    ```compose
    let mut count = 0;
    count = count + 1;
    assert::eq(count, 1);
    ```

    > Compose encourages immutability for clarity, but allows mutation when it’s explicitly requested.

    ---

    ### 🚫 Uninitialized Bindings

    In Compose, you can declare a variable without giving it an initial value.

    This can be useful when multiple branches assign different values to the same variable:

    ```compose
    let x;
    if (true) {
        x = 1;
    } else {
        x = 2;
    };
    assert::eq(x, 1);
    ```

    > However, in this instance we might use the fact that `if` is an expression to assign the intended value to x directly.
    > ```compose
    > let x = if (true) { 1; } else { 2; };
    > assert::eq(x, 1);
    > ```

    Reading an uninitialized variable is allowed, but emits a warning and produces the unit value ()
    You should avoid relying on this behavior.

    ```compose warn(W0001)
    let x;
    assert::eq(x, ()); // ⚠️ Warning: x was used before being assigned a value
    ```

    ```output warn(W0001)
    // autogenerated
    ```

    ---

    ### 📚 Variable Scope

    The **scope** of a variable starts where it is declared and ends at the closing brace of the block that contains it.

    ```compose error(E0011)
    let outer = 10;
    {
        let inner = 20;
        assert::eq(outer, 10);
        assert::eq(inner, 20);
    };
    assert::eq(inner, 10); // ❌ Error: `inner` is not visible here
    ```

    ```output error(E0011)
    // autogenerated
    ```

    Variables can shadow earlier bindings in a new scope:

    ```compose
    let value = 1;
    {
        let value = value + 1;
        assert::eq(value, 2);
    };
    assert::eq(value, 1);
    ```

    Variables can also be shadowed in the same scope:

    ```compose
    let x = 1;
    let x = x + 1; // shadowing, not mutation
    assert::eq(x, 2);
    ```

    > Shadowing is a way to “reuse” names safely. Each binding is separate and lives in its own scope.

    ---

    ### ✅ Summary

    * Variables are immutable by default. Use `let mut` to allow mutation.
    * Use `let` to bind values or patterns.
    * Variables can be uninitialised and resolve to `()` before assignment.
    * Scoping rules help prevent accidental usage of invalid or stale values.
    * Shadowing lets you reuse names in a controlled and explicit way.
    */
    pub mod C2_Variables_and_Scopes {}
);

compose_doc!(
    /**
    ## 🧠 Functions and Closures

    Functions and closures are essential building blocks in Compose. They allow you to reuse logic, abstract behavior, and structure your code clearly and concisely.

    Let’s walk through how function calls work, how to define closures, and how variable capturing works in Compose.

    ---

    ### ☎️ Calling Functions

    Function calls in Compose use parentheses to pass arguments, just like most languages:

    ```compose
    # let add = { x, y => x + y; };
    print("Hello!");
    add(1, 2);
    ```

    You can call:

    * Built-in functions like `print`, `assert::eq`, etc.
    * User-defined closures or functions

    Function arguments are **evaluated left to right** and passed by value unless a reference is explicitly requested (e.g., via `ref` or `ref mut`).

    ---

    ### 🧬 Closures: Inline Functions

    Closures are anonymous functions that you can assign to variables, pass around, and call later.

    Basic syntax:

    ```compose
    let double = { x => x * 2; };
    assert::eq(double(5), 10);
    ```

    Closures can take any number of arguments and produce a value:

    ```compose
    let greet = { name => "Hi, " + name + "!"; };
    assert::eq(greet("Pieter"), "Hi, Pieter!");
    ```

    > Closures are **expressions**, so you can use them inline, assign them to variables, or return them from other functions.

    ---

    ### 🧲 Capturing Variables

    Closures can **capture variables** from their surrounding environment. In Compose, only **boxed values** (`box`) can be captured by reference. This helps ensure clarity and memory safety.

    Variables need to be captured explicitly using a capture list: `let closure = |x| () => x + 1;` (the `|x|` part is the capture list).


    #### ✅ Capturing by Reference

    ```compose
    let mut b = box::new(10);

    let get = { |ref b| => *b; };
    assert::eq(get(), 10);

    *b = 20;
    assert::eq(get(), 20); // Closure sees the updated value
    ```

    This is powerful when closures need to access or mutate shared state.

    #### 🧯 Capturing Mutably

    To mutate a captured box inside a closure, use `ref mut`:

    ```compose
    let mut b = box::new(1);

    let inc = { |ref mut b| => *b = *b + 1; };

    inc();
    assert::eq(*b, 2);
    ```

    ---

    ### 🔒 Owned Captures (by value)

    Compose also supports *owned captures*, where the closure takes ownership of a value from its environment:

    ```compose
    let a = 42;
    let closure = { |a| => a + 1; };
    assert::eq(closure(), 43);
    ```

    > Owned captures cannot refer to boxed values (you must use `ref` or `ref mut` instead).

    ---

    ### 🛠 Higher-Order Usage

    Closures can be returned from functions or passed to other functions:

    ```compose
    let make_adder = { base => { |base| x => x + base; }; };

    let add_five = make_adder(5);
    assert::eq(add_five(3), 8);
    ```

    Compose’s support for closures enables expressive patterns without boilerplate.

    ---

    ### ✅ Summary

    ```markdown
    | Feature                | Syntax                           | Notes                                   |
    | ---------------------- | -------------------------------- | --------------------------------------- |
    | Basic closure          | `(x) => x * 2`                   | Anonymous function                      |
    | Call closure           | `f(5)`                           | Works just like calling a function      |
    | Capture by reference   | `|ref y| () => *y + 1`           | Can read the captured boxed value       |
    | Capture by mut ref     | `|ref mut y| () => { *y += 1; }` | Can mutate the captured boxed value     |
    | Owned capture (by val) | `|y| () => y + 1`                | Captures a copy (non-boxed values only) |
    ```

    Compose makes closures easy to write and reason about, with clear scoping and safe capturing.
    */
    pub mod C4_Functions_and_closures {}
);
