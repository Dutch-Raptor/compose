use compose_doc_macros::compose_doc;

compose_doc!(
    /**
    ## ðŸ§© Variables, Let Bindings, and Scoping

    Variables in Compose are introduced using the `let` keyword. Every variable has a *scope*â€”the region of code where it is visibleâ€”and Compose is designed to make variable behavior clear and predictable.

    ### ðŸ“Œ Let Bindings

    To bind a value to a name, use `let`:

    ```compose
    let x = 10;
    let name = "Compose";
    ```

    By default, variables are **immutable**â€”once assigned, they cannot be changed:

    ```compose error(E0004)
    let x = 5;
    x = 6; // âŒ Error: cannot assign to immutable variable
    ```

    ```output error(E0004)
    // autogenerated
    ```

    If you want to change the value later, use `let mut` to make the variable mutable:

    ```compose
    let mut count = 0;
    count = count + 1;
    assert::eq(count, 1);
    ```

    > Compose encourages immutability for clarity, but allows mutation when itâ€™s explicitly requested.

    ---

    ### ðŸš« Uninitialized Bindings

    In Compose, you can declare a variable without giving it an initial value.

    This can be useful when multiple branches assign different values to the same variable:

    ```compose
    let x;
    if (true) {
        x = 1;
    } else {
        x = 2;
    };
    assert::eq(x, 1);
    ```

    > However, in this instance we might use the fact that `if` is an expression to assign the intended value to x directly.
    > ```compose
    > let x = if (true) { 1; } else { 2; };
    > assert::eq(x, 1);
    > ```

    Reading an uninitialized variable is allowed, but emits a warning and produces the unit value ()
    You should avoid relying on this behavior.

    ```compose warn(W0001)
    let x;
    assert::eq(x, ()); // âš ï¸ Warning: x was used before being assigned a value
    ```

    ```output warn(W0001)
    // autogenerated
    ```

    ---

    ### ðŸ“š Variable Scope

    The **scope** of a variable starts where it is declared and ends at the closing brace of the block that contains it.

    ```compose error(E0011)
    let outer = 10;
    {
        let inner = 20;
        assert::eq(outer, 10);
        assert::eq(inner, 20);
    };
    assert::eq(inner, 10); // âŒ Error: `inner` is not visible here
    ```

    ```output error(E0011)
    // autogenerated
    ```

    Variables can shadow earlier bindings in a new scope:

    ```compose
    let value = 1;
    {
        let value = value + 1;
        assert::eq(value, 2);
    };
    assert::eq(value, 1);
    ```

    Variables can also be shadowed in the same scope:

    ```compose
    let x = 1;
    let x = x + 1; // shadowing, not mutation
    assert::eq(x, 2);
    ```

    > Shadowing is a way to â€œreuseâ€ names safely. Each binding is separate and lives in its own scope.

    ---

    ### âœ… Summary

    * Variables are immutable by default. Use `let mut` to allow mutation.
    * Use `let` to bind values or patterns.
    * Variables can be uninitialised and resolve to `()` before assignment.
    * Scoping rules help prevent accidental usage of invalid or stale values.
    * Shadowing lets you reuse names in a controlled and explicit way.
    */
    pub mod C2_Variables_and_Scopes {}
);

compose_doc!(
    /**
    ## ðŸ§  Functions and Closures

    Functions and closures are essential building blocks in Compose. They allow you to reuse logic, abstract behavior, and structure your code clearly and concisely.

    Letâ€™s walk through how function calls work, how to define closures, and how variable capturing works in Compose.

    ---

    ### â˜Žï¸ Calling Functions

    Function calls in Compose use parentheses to pass arguments, just like most languages:

    ```compose
    # let add = { x, y => x + y; };
    print("Hello!");
    add(1, 2);
    ```

    You can call:

    * Built-in functions like `print`, `assert::eq`, etc.
    * User-defined closures or functions

    Function arguments are **evaluated left to right** and passed by value unless a reference is explicitly requested (e.g., via `ref` or `ref mut`).

    ---

    ### ðŸ§¬ Closures: Inline Functions

    Closures are anonymous functions that you can assign to variables, pass around, and call later.

    Basic syntax:

    ```compose
    let double = { x => x * 2; };
    assert::eq(double(5), 10);
    ```

    Closures can take any number of arguments and produce a value:

    ```compose
    let greet = { name => "Hi, " + name + "!"; };
    assert::eq(greet("Pieter"), "Hi, Pieter!");
    ```

    > Closures are **expressions**, so you can use them inline, assign them to variables, or return them from other functions.

    ---

    ### ðŸ§² Capturing Variables

    Closures can **capture variables** from their surrounding environment. In Compose, only **boxed values** (`box`) can be captured by reference. This helps ensure clarity and memory safety.

    Variables need to be captured explicitly using a capture list: `let closure = |x| () => x + 1;` (the `|x|` part is the capture list).


    #### âœ… Capturing by Reference

    ```compose
    let mut b = box::new(10);

    let get = { |ref b| => *b; };
    assert::eq(get(), 10);

    *b = 20;
    assert::eq(get(), 20); // Closure sees the updated value
    ```

    This is powerful when closures need to access or mutate shared state.

    #### ðŸ§¯ Capturing Mutably

    To mutate a captured box inside a closure, use `ref mut`:

    ```compose
    let mut b = box::new(1);

    let inc = { |ref mut b| => *b = *b + 1; };

    inc();
    assert::eq(*b, 2);
    ```

    ---

    ### ðŸ”’ Owned Captures (by value)

    Compose also supports *owned captures*, where the closure takes ownership of a value from its environment:

    ```compose
    let a = 42;
    let closure = { |a| => a + 1; };
    assert::eq(closure(), 43);
    ```

    > Owned captures cannot refer to boxed values (you must use `ref` or `ref mut` instead).

    ---

    ### ðŸ›  Higher-Order Usage

    Closures can be returned from functions or passed to other functions:

    ```compose
    let make_adder = { base => { |base| x => x + base; }; };

    let add_five = make_adder(5);
    assert::eq(add_five(3), 8);
    ```

    Composeâ€™s support for closures enables expressive patterns without boilerplate.

    ---

    ### âœ… Summary

    ```markdown
    | Feature                | Syntax                           | Notes                                   |
    | ---------------------- | -------------------------------- | --------------------------------------- |
    | Basic closure          | `(x) => x * 2`                   | Anonymous function                      |
    | Call closure           | `f(5)`                           | Works just like calling a function      |
    | Capture by reference   | `|ref y| () => *y + 1`           | Can read the captured boxed value       |
    | Capture by mut ref     | `|ref mut y| () => { *y += 1; }` | Can mutate the captured boxed value     |
    | Owned capture (by val) | `|y| () => y + 1`                | Captures a copy (non-boxed values only) |
    ```

    Compose makes closures easy to write and reason about, with clear scoping and safe capturing.
    */
    pub mod C4_Functions_and_closures {}
);
