use std::fmt::Write;
use std::fs;
use std::path::Path;

fn main() {
    let mut files = walkdir::WalkDir::new("src/codes")
        .into_iter()
        .filter_map(Result::ok)
        .filter(|e| e.file_type().is_file() && e.path().extension().unwrap_or_default() == "md")
        .collect::<Vec<_>>();

    // Sort for build determinism
    files.sort_by_key(|f| f.path().to_owned());

    let out_dir = std::env::var("OUT_DIR").expect("OUT_DIR is always set during builds");
    let codes_path = "src/codes";
    println!("cargo:rerun-if-changed={codes_path}");

    let mut out = String::new();
    out.push_str("// This file is @generated by build.rs\n");

    let mut lookup_matches = String::new();
    let mut error_codes = String::new();

    for file in files {
        let path = file.path();
        println!("cargo:rerun-if-changed={}", path.display());
        let name = file
            .path()
            .file_stem()
            .and_then(|s| s.to_str())
            .expect("invalid file name")
            .to_uppercase();
        let split = name.split('_').collect::<Vec<_>>();
        assert!(
            split.len() >= 2,
            "invalid file name: {name}. Expected CODE_NAME.md",
        );
        let code = split[0];
        let title = split[1..].join(" ");

        let contents = fs::read_to_string(file.path()).expect("Failed to read file");

        // Create the documentation
        out.push_str("/**");
        out.push_str(contents.as_str());
        out.push_str("*/");
        write!(
            out,
            r#"
            pub const {name}: ErrorCode = ErrorCode {{
                code: "{code}",
                name: "{title}",
                description: "{contents}",
            }};
        "#,
            contents = escape(&contents),
        )
        .expect("writing to a string is infallible");
        out.push_str("\n\n");

        write!(
            lookup_matches,
            r#"
                "{code}" => &{name},
            "#,
        )
        .expect("writing to a string is infallible");

        write!(
            error_codes,
            r#"
                &{name},
            "#,
        ).expect("writing to a string is infallible");
    }

    write!(
        out,
        r#"
        /// Find an error code by its code.
        #[must_use]
        pub fn lookup(code: &str) -> Option<&'static ErrorCode> {{
            Some(match code {{
                {lookup_matches}
                _ => return None,
            }})
        }}

        pub const ERROR_CODES: &[&ErrorCode] = &[
            {error_codes}
        ];
    "#
    )
    .expect("writing to a string is infallible");
    
    fs::write(Path::new(&out_dir).join("Error_Codes"), out)
        .expect("failed to write Error_Codes");
}

fn escape(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
}
