/*!
# Compose Markdown Processor

This crate provides a utility for automatically processing fenced code blocks in Markdown files, evaluating `compose` code, and generating verified documentation that stays in sync with runtime behaviour.

This is especially useful for:
- **Tutorials and learning material**
- **Code documentation with expected errors/warnings**
- **Doc-tests with output and diagnostics**
- **Generating error explanation pages**

---

## ‚ú® Features

- ‚úÖ Evaluate `compose` code blocks inline
- ‚úÖ Automatically check for expected errors or warnings
- ‚úÖ Capture output (`stdout`) from code blocks
- ‚úÖ Use `#` to hide setup lines from rendered output (like Rustdoc)
- ‚úÖ Emit diagnostics only when referenced explicitly
- ‚úÖ Full test coverage to ensure docs don‚Äôt go out of sync

---

## üöÄ Usage

### Compose block with captured output

````markdown
```compose
# let name = "World";
println("Hello, " + name + "!");
```

Output:

```output stdout
// output will be automatically filled
```
````

### Compose block with expected diagnostics

````markdown
```compose error(E0004)
let a = 3;
a = 5; // ‚ùå cannot assign to immutable variable
```

Error:

```output error(E0004)
// error message will be inserted here
```
````

---

## üß™ Running `transform_markdown`

You can call `transform_markdown(markdown, config)` to convert your Markdown source string into one that includes:

- Verified code blocks
- Auto-generated diagnostic blocks
- Correct output (e.g. printed values)

Example:

`````rust
use compose_doc::{transform_markdown, Config};

let input = r#"
```compose
println("hi!");
```

```output stdout
// output will be automatically filled
```
"#;

let result = transform_markdown(input, &Config::new()).unwrap();
assert_eq!(result.trim(),
r#"
````compose
println("hi!");
````

````text
hi!
````
"#.trim())
`````

---

## üß© Code Block Header DSL

You can specify metadata for a code block using space-separated flags:

- `compose error(E0001)` ‚Äì expects an error with code `E0001`
- `output stdout` ‚Äì emits the standard output of the preceding block
- `warn(W0002)` ‚Äì expects a warning with code `W0002`

You can combine these:

````markdown
```output error(E0001) warn(W0002) stdout
```
````

---

## üïµ Hidden Setup Code

Any line prefixed with `#` will still be evaluated but omitted from the rendered output.

````markdown
```compose
# let x = 42;
println(x);
```

```output stdout
// output will be automatically filled
```

````

---

## üßº Error Handling

If a block:
- emits diagnostics not marked with `error(...)` or `warn(...)`, or
- claims to emit diagnostics that aren‚Äôt produced by the code,

then `transform_markdown` will fail with a line-referenced error.

---

## üõ†Ô∏è Configuration

```rust
use compose_doc::Config;
let config = Config::ansi();      // diagnostics with colour
let config = Config::no_color();  // plain-text diagnostics
```
*/
mod block;
mod diag;
mod markdown;
mod realise;
mod world;

pub use diag::Error;
pub use markdown::*;

#[cfg(test)]
mod tests {
    use crate::Config;
    use crate::markdown::transform_markdown;
    use indoc::indoc;

    #[test]
    fn test_transform_markdown() {
        let input = indoc! {r#"
            ```compose
            println("hi");
            ```

            ```output stdout
            // autogenerated
            ```
        "#};

        let output =
            transform_markdown(input, &Config::default()).expect("failed to transform markdown");

        assert_eq!(
            output.trim(),
            indoc! {r#"
        ````compose
        println("hi");
        ````

        ````text
        hi
        ````
        "#}
            .trim()
        );
    }

    #[test]
    fn marked_error_ok() {
        let input = indoc! {r#"
            ```compose error(E0004)
            let a = 4; // immutable
            a = 5; // Error, cannot assign to immutable variable
            ```
        "#};

        let output =
            transform_markdown(input, &Config::new()).expect("failed to transform markdown");

        assert_eq!(
            output.trim(),
            indoc! {r#"
        ````compose error(E0004)
        let a = 4; // immutable
        a = 5; // Error, cannot assign to immutable variable
        ````
        "#}
            .trim()
        );
    }

    #[test]
    fn unmarked_error_fails() {
        let input = indoc! {r#"
            ```compose
            let a = 4; // immutable
            a = 5; // Error, cannot assign to immutable variable, unmarked
            ```
        "#};

        let err = transform_markdown(input, &Config::new()).expect_err("markdown should fail");

        assert!(err.message.contains("E0004"));
        assert_eq!(err.line, 0);
    }

    #[test]
    fn overmarked_error_fails() {
        // marked to error, but no error in the code
        let input = indoc! {r#"
            ```compose error(E0004)
            let a = 4;
            ```
        "#};

        let err = transform_markdown(input, &Config::new()).expect_err("markdown should fail");

        assert!(err.message.contains("E0004"));
        assert_eq!(err.line, 0);
    }

    #[test]
    fn marked_warn_ok() {
        let input = indoc! {r#"
            ```compose warn(W0001)
            let a; // uninitialised
            a; // Warn, a was uninitialised
            ```
        "#};

        let output =
            transform_markdown(input, &Config::new()).expect("failed to transform markdown");

        assert_eq!(
            output.trim(),
            indoc! {r#"
            ````compose warn(W0001)
            let a; // uninitialised
            a; // Warn, a was uninitialised
            ````
        "#}
            .trim()
        );
    }

    #[test]
    fn diag_output() {
        let input = indoc! {r#"
            ```compose error(E0004)
            let a = 4; // immutable
            a = 5; // Error, cannot assign to immutable variable, unmarked
            ```

            Error:
            ```output error(E0004)
            // autogenerated
            ```
        "#};

        let output =
            transform_markdown(input, &Config::no_color()).expect("failed to transform markdown");

        assert_eq!(
            output.trim(),
            indoc! {"
            ````compose error(E0004)
            let a = 4; // immutable
            a = 5; // Error, cannot assign to immutable variable, unmarked
            ````
            
            Error:

            ````text
            error[E0004]: cannot reassign to a variable declared as immutable
              ‚îå‚îÄ main.comp:2:1
              ‚îÇ
            1 ‚îÇ let a = 4; // immutable
              ‚îÇ     - was defined as immutable here
            2 ‚îÇ a = 5; // Error, cannot assign to immutable variable, unmarked
              ‚îÇ ^ is immutable
              ‚îÇ
              = note: variables are immutable by default
              = help: make the variable mutable by writing `let mut`
              = help: for more information about this error, try `compose explain E0004`
            ````

        "}
            .trim()
        );
    }

    #[test]
    fn hidden_code() {
        let input = indoc! {r#"
            ```compose
            # let name = "Bob";
            println("Hi, " + name + "!"); // Hi, Bob!
            ```
            
            Stdout:
            
            ```output stdout
            // autogenerated
            ```
        "#};

        let output =
            transform_markdown(input, &Config::no_color()).expect("failed to transform markdown");

        assert_eq!(
            output.trim(),
            indoc! {r##"
            ````compose
            println("Hi, " + name + "!"); // Hi, Bob!
            ````
            
            Stdout:
            
            ````text
            Hi, Bob!
            ````
            "##}
            .trim()
        );
    }
}
