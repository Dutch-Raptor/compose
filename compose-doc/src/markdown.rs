use crate::block::{parse_block_header, BlockHeader};
use crate::diag::{diagnostics_to_string, line_starts, offset_to_line, At, Error};
use crate::realise::{eval_code, EvalResult};
use compose_error_codes::{lookup, ErrorCode};
use compose_library::diag::SourceDiagnostic;
use pulldown_cmark::{CodeBlockKind, Event, OffsetIter, Options, Parser, Tag};
use std::cmp::PartialEq;
use std::iter::Peekable;

pub struct Config {
    pub diag_mode: DiagMode,
    /// How to handle unexpected warnings and errors in code blocks
    pub code_block_error_mode: ErrorHandlingMode,
    /// How to handle warnings and errors in output blocks that don't occur
    pub output_block_error_mode: ErrorHandlingMode,
}

#[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]
pub enum ErrorHandlingMode {
    EmitAsTests,
    Error,
    Ignore,
}

impl Config {
    #[must_use]
    pub const fn new() -> Self {
        Self {
            diag_mode: DiagMode::Ansi,
            code_block_error_mode: ErrorHandlingMode::Error,
            output_block_error_mode: ErrorHandlingMode::Error,
        }
    }

    #[must_use]
    pub const fn with_ansi(mut self) -> Self {
        self.diag_mode = DiagMode::Ansi;
        self
    }

    #[must_use]
    pub const fn with_no_color(mut self) -> Self {
        self.diag_mode = DiagMode::NoColor;
        self
    }

    #[must_use]
    pub const fn with_code_block_error_mode(mut self, mode: ErrorHandlingMode) -> Self {
        self.code_block_error_mode = mode;
        self
    }

    #[must_use]
    pub const fn with_output_block_error_mode(mut self, mode: ErrorHandlingMode) -> Self {
        self.output_block_error_mode = mode;
        self
    }
}

impl Default for Config {
    fn default() -> Self {
        Self::new()
    }
}

pub enum DiagMode {
    Ansi,
    NoColor,
}

pub struct Ir<'a> {
    events: Vec<DocIr<'a>>,
}

impl<'a> Ir<'a> {
    fn new() -> Self {
        Self { events: Vec::new() }
    }

    fn push_other(&mut self, event: Event<'a>) {
        if !matches!(self.events.last(), Some(DocIr::Other(_))) {
            self.events.push(DocIr::Other(Vec::new()));
        }

        if let Some(DocIr::Other(events)) = self.events.last_mut() {
            events.push(event);
        } else {
            unreachable!();
        }
    }

    fn push_compose_block(&mut self, block: ComposeBlock) {
        self.events.push(DocIr::ComposeBlock(block));
    }

    fn push_output_block(&mut self, block: OutputBlock) {
        self.events.push(DocIr::OutputBlock(block));
    }

    fn last_compose_block_mut(&mut self) -> Option<&mut ComposeBlock> {
        self.events.iter_mut().rev().find_map(|v| match v {
            DocIr::ComposeBlock(block) => Some(block),
            _ => None,
        })
    }
}

enum DocIr<'a> {
    ComposeBlock(ComposeBlock),
    OutputBlock(OutputBlock),
    Other(Vec<Event<'a>>),
}

pub struct ComposeBlock {
    display: String,
    raw: String,
    line: usize,
    header: String,
    output_uses: Vec<OutputBlockDiags>,
    eval: EvalResult,
}

pub struct OutputBlockDiags {
    pub errors: Vec<&'static ErrorCode>,
    pub warnings: Vec<&'static ErrorCode>,
    pub line_number: usize,
}

pub struct OutputBlock {
    contents: String,
}

/// Transforms Markdown by evaluating fenced `compose` code blocks and replacing/validating
/// adjacent `output` blocks.
///
/// # Syntax
///
/// A `compose` block executes code in the Compose VM:
///
/// ````markdown
/// ```compose error(E0001) warn(W0002)
/// let a = 3;
/// a = 4; // triggers E0001
/// ```
/// ````
///
/// An optional `output` block follows, specifying which outputs to generate:
///
/// ````markdown
/// Error:
///
/// ```output error(E0001)
/// // the diagnostic will be automatically inserted here
/// ```
/// ````
///
/// You can also emit `stdout` and combine outputs:
///
/// ````markdown
/// ```output error(E0001) warn(W0002) stdout
/// ````
///
/// # Hiding Setup Lines
///
/// Any line in a `compose` block starting with `#` is *executed* but *not shown* in the final
/// output. This is useful for setup:
///
/// ```compose
/// ## let name = "Alice";
/// println("Hello, " + name + "!");
/// ```
///
/// # Errors
///
/// - Returns an [`Error`] if an expected diagnostic is missing
/// - Or if an unexpected diagnostic occurs
/// - Or if the code block header is malformed
///
/// # Config
///
/// Output formatting is controlled by the [`Config`] parameter. Use `Config::no_color()`
/// to emit raw text (suitable for CI diffs), or `Config::ansi()` for colored output.
///
/// # Example
///
/// `````
/// use compose_doc::{transform_markdown, Config};
/// let markdown = r#"
/// ```compose error(E0004)
/// let a = 4;
/// a = 5;
/// ```
///
/// ```output error(E0004)
/// // autogenerated
/// ```
/// "#;
///
/// let rendered = transform_markdown(markdown, &Config::new().with_no_color()).unwrap();
/// assert_eq!(rendered.trim(), r#"
/// ````compose error(E0004)
/// let a = 4;
/// a = 5;
/// ````
///
/// ````text
/// error[E0004]: cannot reassign to a variable declared as immutable
///   ┌─ main.comp:2:1
///   │
/// 1 │ let a = 4;
///   │     - was defined as immutable here
/// 2 │ a = 5;
///   │ ^ is immutable
///   │
///   = note: variables are immutable by default
///   = help: make the variable mutable by writing `let mut`
///   = help: for more information about this error, try `compose explain E0004`
/// ````
/// "#.trim());
/// `````
pub fn transform_markdown(input: &str, config: &Config) -> Result<String, Error> {
    let line_starts = line_starts(input, 0).collect::<Vec<_>>();

    let mut parser = Parser::new_ext(
        input,
        Options::ENABLE_SUBSCRIPT
            | Options::ENABLE_SUPERSCRIPT
            | Options::ENABLE_TABLES
            | Options::ENABLE_STRIKETHROUGH
            | Options::ENABLE_FOOTNOTES
            | Options::ENABLE_GFM
            | Options::ENABLE_MATH,
    )
    .into_offset_iter()
    .peekable();
    let events = rewrite_code_blocks(&line_starts, &mut parser, config)?;

    let mut result = String::new();
    pulldown_cmark_to_cmark::cmark(events.into_iter(), &mut result)
        .map_err(|err| format!("failed to convert events to cmark: {err}"))
        .at(0)?;
    Ok(result)
}

#[derive(Default)]
struct BlockContext {
    last_eval: Option<EvalResult>,
}

/// Performs a two-pass rewrite of the Markdown, replacing `compose` and `output` blocks with
/// their rendered output.
///
/// Depending on configuration options, rust doc tests can be emitted for inclusion in generated
/// doc comments.
fn rewrite_code_blocks<'a>(
    line_starts: &[usize],
    parser: &mut Peekable<OffsetIter<'a>>,
    config: &Config,
) -> Result<Vec<Event<'a>>, Error> {
    let mut ctx = BlockContext::default();
    let mut ir = Ir::new();

    while let Some((event, offset)) = parser.next() {
        match &event {
            Event::Start(Tag::CodeBlock(CodeBlockKind::Fenced(info))) => {
                let line = offset_to_line(line_starts, offset.start);
                let meta = parse_block_header(info.as_ref()).at(line)?;

                match meta.lang.as_str() {
                    "compose" => {
                        let (code, raw) = parse_code_block(parser);
                        let eval = eval_code(&raw);
                        ctx.last_eval = Some(eval.clone());

                        ir.push_compose_block(ComposeBlock {
                            display: code,
                            raw,
                            line,
                            header: info.to_string(),
                            output_uses: vec![],
                            eval,
                        });
                    }
                    "output" => {
                        let last_compose_block = ir
                            .last_compose_block_mut()
                            .ok_or("missing preceding compose block")
                            .at(line)?;

                        let (output, diags) = parse_output_block(
                            parser,
                            &last_compose_block.eval,
                            &meta,
                            line,
                            config,
                        )?;

                        last_compose_block.output_uses.push(diags);

                        ir.push_output_block(output);
                    }
                    _ => ir.push_other(event.clone()),
                }
            }
            _ => {
                ir.push_other(event.clone());
            }
        }
    }

    let mut events = Vec::new();
    for block in ir.events {
        match block {
            DocIr::ComposeBlock(compose_block) => {
                if config.output_block_error_mode == ErrorHandlingMode::Error {
                    verify_output_block_errors_and_warnings(&compose_block)?;
                }
                match config.code_block_error_mode {
                    ErrorHandlingMode::EmitAsTests => {
                        let meta =
                            parse_block_header(&compose_block.header).at(compose_block.line)?;
                        let mut rust_test =
                            code_block_as_rust_test(&compose_block.raw, &meta, compose_block.line)?;

                        if config.output_block_error_mode == ErrorHandlingMode::EmitAsTests {
                            emit_output_diags_tests(&compose_block.output_uses, &mut rust_test);
                        }

                        events.extend(emit_code_block("rust".to_string(), rust_test));
                    }
                    ErrorHandlingMode::Error => {
                        let meta =
                            parse_block_header(&compose_block.header).at(compose_block.line)?;
                        let (expected_errors, expected_warnings) =
                            parse_expected_errors_and_warnings(&meta).at(compose_block.line)?;
                        let eval_result = &compose_block.eval;

                        verify_warnings_and_errors(
                            &eval_result,
                            &expected_errors,
                            &expected_warnings,
                        )
                        .at(compose_block.line)?;

                        events.extend(emit_code_block(
                            compose_block.header.to_string(),
                            compose_block.display,
                        ));
                    }
                    ErrorHandlingMode::Ignore => {
                        events.extend(emit_code_block(
                            compose_block.header.to_string(),
                            compose_block.display,
                        ));
                    }
                }
            }
            DocIr::OutputBlock(output) => {
                events.extend(emit_code_block("text".to_string(), output.contents));
            }
            DocIr::Other(e) => events.extend(e),
        }
    }

    Ok(events)
}

/// returns (expected_errors, expected_warnings)
pub(crate) fn parse_expected_errors_and_warnings(
    meta: &BlockHeader,
) -> Result<(Vec<&ErrorCode>, Vec<&ErrorCode>), String> {
    let expected_errors = meta
        .expected_errors
        .iter()
        .map(|code| lookup(code).ok_or_else(|| format!("{code} is not a valid error code")))
        .collect::<Result<Vec<_>, _>>()?;

    let expected_warnings = meta
        .expected_warnings
        .iter()
        .map(|code| lookup(code).ok_or(format!("{code} is not a valid warning code")))
        .collect::<Result<Vec<_>, _>>()?;

    Ok((expected_errors, expected_warnings))
}

/// Emits tests for error and warning annotations in output blocks.
///
/// Ensures that the interpreter actually raised warnings and errors the output block wants to show
///
/// Expects an EvalResult named `result` to be defined.
fn emit_output_diags_tests(output_diags: &[OutputBlockDiags], rust_test: &mut String) {
    rust_test.push_str("\n");
    for output_use in output_diags {
        for error in &output_use.errors {
            rust_test.push_str(&format!(
                "# assert!(result.errors().iter().any(|e| e.code.map(|c| c.code) == Some(\"{error}\")), \"Output block expected error code {error} at line {line}\");\n",
                error = error.code, line = output_use.line_number));
        }

        for warning in &output_use.warnings {
            rust_test.push_str(&format!(
                "# assert!(result.warnings().iter().any(|e| e.code.map(|c| c.code) == Some(\"{warning}\")), \"Output block expected warning code {warning} at line {line}\");\n",
                warning = warning.code, line = output_use.line_number));
        }
    }
}

fn verify_output_block_errors_and_warnings(compose_block: &ComposeBlock) -> Result<(), Error> {
    for output_use in &compose_block.output_uses {
        for error in &output_use.errors {
            if !compose_block
                .eval
                .errors
                .iter()
                .any(|e| e.code.map(|c| c.code) == Some(error.code))
            {
                return Err(format!(
                    "Output block expected error code {error} at line {line}",
                    error = error.code,
                    line = output_use.line_number
                ))
                .at(output_use.line_number);
            }
        }

        for warning in &output_use.warnings {
            if !compose_block
                .eval
                .errors
                .iter()
                .any(|w| w.code.map(|c| c.code) == Some(warning.code))
            {
                return Err(format!(
                    "Output block expected warning code {warning} at line {line}",
                    warning = warning.code,
                    line = output_use.line_number
                ))
                .at(output_use.line_number);
            }
        }
    }
    Ok(())
}

fn verify_warnings_and_errors(
    eval_result: &EvalResult,
    expected_errors: &[&ErrorCode],
    expected_warnings: &[&ErrorCode],
) -> Result<(), String> {
    if !eval_result
        .errors
        .iter()
        .map(|e| e.code)
        .zip(expected_errors)
        .all(|(a, b)| a == Some(b))
        || eval_result.errors.len() != expected_errors.len()
    {
        let errors_str = diagnostics_to_string(
            &eval_result.world,
            &eval_result.errors,
            &[],
            &Config::new().with_no_color(),
        );
        return Err(format!(
            "expected errors: {expected_errors:?}, got:\n{errors_str}"
        ));
    }

    if !eval_result
        .warnings
        .iter()
        .map(|e| e.code)
        .zip(expected_warnings)
        .all(|(a, b)| a == Some(b))
        || eval_result.warnings.len() != expected_warnings.len()
    {
        let warnings_str = diagnostics_to_string(
            &eval_result.world,
            &[],
            &eval_result.warnings,
            &Config::new().with_no_color(),
        );
        return Err(format!(
            "expected warnings: {expected_warnings:?}, got:\n{warnings_str}"
        ));
    }

    Ok(())
}

fn code_block_as_rust_test(raw: &str, meta: &BlockHeader, line: usize) -> Result<String, Error> {
    let (expected_errors, expected_warnings) = parse_expected_errors_and_warnings(meta).at(line)?;

    let mut code = String::new();
    code.push_str("# use ::compose_eval::test::eval_code;\n");
    code.push_str("# use ::compose_error_codes::*;\n");
    code.push_str(&format!(
        "# let expected_errors = [{}];\n",
        expected_errors
            .iter()
            .map(|e| format!("lookup(\"{}\").unwrap()", e.code))
            .collect::<Vec<_>>()
            .join(", ")
    ));
    code.push_str(&format!(
        "# let expected_warnings = [{}];\n",
        expected_warnings
            .iter()
            .map(|e| format!("lookup(\"{}\").unwrap()", e.code))
            .collect::<Vec<_>>()
            .join(", ")
    ));
    code.push_str("# let result = eval_code(r#\"\n");
    code.push_str(raw);
    if !raw.ends_with('\n') {
        code.push('\n');
    }
    code.push_str("# \"#)\n");
    code.push_str("# .assert_errors(&expected_errors)\n");
    code.push_str("# .assert_warnings(&expected_warnings);");

    Ok(code)
}

/// Parses a code block into a display and raw code
fn parse_code_block(parser: &mut Peekable<OffsetIter<'_>>) -> (String /*display*/, String /*raw*/) {
    let mut display = String::new();
    let mut raw = String::new();

    while let Some((Event::Text(text), _)) = parser.peek() {
        for line in text.lines() {
            let trimmed = line.trim_start();
            let indent_len = line.len() - trimmed.len();

            if let Some(stripped) = trimmed.strip_prefix("# ") {
                // Strip `#` but keep the original indentation
                raw.push_str(&line[..indent_len]); // leading spaces
                raw.push_str(stripped); // the rest of the line after `# `
                if !raw.ends_with('\n') {
                    raw.push('\n');
                }
                // Do not include in display
            } else {
                raw.push_str(line);
                if !raw.ends_with('\n') {
                    raw.push('\n');
                }

                display.push_str(line);
                if !display.ends_with('\n') {
                    display.push('\n');
                }
            }
        }
        parser.next();
    }

    (display, raw)
}

fn parse_output_block(
    parser: &mut Peekable<OffsetIter<'_>>,
    last_eval: &EvalResult,
    meta: &BlockHeader,
    line: usize,
    config: &Config,
) -> Result<(OutputBlock, OutputBlockDiags), Error> {
    let mut content = String::new();

    while let Some((Event::Text(_), _)) = parser.peek() {
        parser.next(); // discard any content in the code block
    }

    let mut diags = OutputBlockDiags {
        errors: vec![],
        warnings: vec![],
        line_number: line,
    };

    for warning in &meta.expected_warnings {
        if let Ok(diag) = find_diag(&last_eval.warnings, warning, line) {
            content.push_str(&diagnostics_to_string(
                &last_eval.world,
                &[],
                &[diag.clone()],
                config,
            ));
        }

        diags.warnings.push(lookup(warning).unwrap());
    }

    for error in &meta.expected_errors {
        if let Ok(diag) = find_diag(&last_eval.errors, error, line) {
            content.push_str(&diagnostics_to_string(
                &last_eval.world,
                &[diag.clone()],
                &[],
                config,
            ));
        }

        diags.errors.push(lookup(error).unwrap());
    }

    if meta.stdout {
        content.push_str(&last_eval.stdout);
    }

    let output = OutputBlock { contents: content };

    Ok((output, diags))
}

fn find_diag<'a>(
    diags: &'a [SourceDiagnostic],
    code_str: &str,
    line: usize,
) -> Result<&'a SourceDiagnostic, Error> {
    let code = lookup(code_str)
        .ok_or_else(|| format!("unknown code: {code_str}"))
        .at(line)?;

    diags
        .iter()
        .find(|d| d.code == Some(code))
        .ok_or_else(|| format!("expected diagnostic code {code_str}"))
        .at(line)
}

fn emit_code_block<'a>(lang: String, code: String) -> Vec<Event<'a>> {
    vec![
        Event::Start(Tag::CodeBlock(CodeBlockKind::Fenced(lang.into()))),
        Event::Text(code.into()),
    ]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_code_block_strips_hash_lines() {
        let input = "```compose\n# let a = 1;\nlet b = a + 1;\n```";
        let mut parser = Parser::new(input).into_offset_iter().peekable();
        // consume the opening ```compose
        parser.next();

        let (display, raw) = parse_code_block(&mut parser);

        assert_eq!(display.trim(), "let b = a + 1;");
        assert_eq!(raw.trim(), "let a = 1;\nlet b = a + 1;");
    }
}
