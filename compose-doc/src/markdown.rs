use crate::block::{BlockHeader, parse_block_header};
use crate::diag::{At, Error, diagnostics_to_string, line_starts, offset_to_line};
use crate::realise::{EvalResult, execute_code_block};
use compose_error_codes::lookup;
use compose_library::diag::SourceDiagnostic;
use pulldown_cmark::{CodeBlockKind, Event, OffsetIter, Options, Parser, Tag};
use std::iter::Peekable;

pub struct Config {
    pub diag_mode: DiagMode,
}

impl Config {
    #[must_use]
    pub const fn new() -> Self {
        Self::ansi()
    }

    #[must_use]
    pub const fn ansi() -> Self {
        Self {
            diag_mode: DiagMode::Ansi,
        }
    }

    #[must_use]
    pub const fn no_color() -> Self {
        Self {
            diag_mode: DiagMode::NoColor,
        }
    }
}

impl Default for Config {
    fn default() -> Self {
        Self::new()
    }
}

pub enum DiagMode {
    Ansi,
    NoColor,
}

/// Transforms Markdown by evaluating fenced `compose` code blocks and replacing/validating
/// adjacent `output` blocks.
///
/// # Syntax
///
/// A `compose` block executes code in the Compose VM:
///
/// ````markdown
/// ```compose error(E0001) warn(W0002)
/// let a = 3;
/// a = 4; // triggers E0001
/// ```
/// ````
///
/// An optional `output` block follows, specifying which outputs to generate:
///
/// ````markdown
/// Error:
///
/// ```output error(E0001)
/// // the diagnostic will be automatically inserted here
/// ```
/// ````
///
/// You can also emit `stdout` and combine outputs:
///
/// ````markdown
/// ```output error(E0001) warn(W0002) stdout
/// ````
///
/// # Hiding Setup Lines
///
/// Any line in a `compose` block starting with `#` is *executed* but *not shown* in the final
/// output. This is useful for setup:
///
/// ```compose
/// ## let name = "Alice";
/// println("Hello, " + name + "!");
/// ```
///
/// # Errors
///
/// - Returns an [`Error`] if an expected diagnostic is missing
/// - Or if an unexpected diagnostic occurs
/// - Or if the code block header is malformed
///
/// # Config
///
/// Output formatting is controlled by the [`Config`] parameter. Use `Config::no_color()`
/// to emit raw text (suitable for CI diffs), or `Config::ansi()` for colored output.
///
/// # Example
///
/// `````
/// use compose_doc::{transform_markdown, Config};
/// let markdown = r#"
/// ```compose error(E0004)
/// let a = 4;
/// a = 5;
/// ```
///
/// ```output error(E0004)
/// // autogenerated
/// ```
/// "#;
///
/// let rendered = transform_markdown(markdown, &Config::no_color()).unwrap();
/// assert_eq!(rendered.trim(), r#"
/// ````compose error(E0004)
/// let a = 4;
/// a = 5;
/// ````
///
/// ````text
/// error[E0004]: cannot reassign to a variable declared as immutable
///   ┌─ main.comp:2:1
///   │
/// 1 │ let a = 4;
///   │     - was defined as immutable here
/// 2 │ a = 5;
///   │ ^ is immutable
///   │
///   = note: variables are immutable by default
///   = help: make the variable mutable by writing `let mut`
///   = help: for more information about this error, try `compose explain E0004`
/// ````
/// "#.trim());
/// `````
pub fn transform_markdown(input: &str, config: &Config) -> Result<String, Error> {
    let line_starts = line_starts(input, 0).collect::<Vec<_>>();

    let mut parser = Parser::new_ext(
        input,
        Options::ENABLE_SUBSCRIPT
            | Options::ENABLE_SUPERSCRIPT
            | Options::ENABLE_TABLES
            | Options::ENABLE_STRIKETHROUGH
            | Options::ENABLE_FOOTNOTES
            | Options::ENABLE_GFM
            | Options::ENABLE_MATH,
    )
    .into_offset_iter()
    .peekable();
    let events = rewrite_code_blocks(&line_starts, &mut parser, config)?;

    let mut result = String::new();
    pulldown_cmark_to_cmark::cmark(events.into_iter(), &mut result)
        .map_err(|err| format!("failed to convert events to cmark: {err}"))
        .at(0)?;
    Ok(result)
}

#[derive(Default)]
struct BlockContext {
    last_eval: Option<EvalResult>,
}

fn rewrite_code_blocks<'a>(
    line_starts: &[usize],
    parser: &mut Peekable<OffsetIter<'a>>,
    config: &Config,
) -> Result<Vec<Event<'a>>, Error> {
    let mut ctx = BlockContext::default();
    let mut events = Vec::new();

    while let Some((event, offset)) = parser.next() {
        match &event {
            Event::Start(Tag::CodeBlock(CodeBlockKind::Fenced(info))) => {
                let line = offset_to_line(line_starts, offset.start);
                let meta = parse_block_header(info.as_ref()).at(line)?;

                match meta.lang.as_str() {
                    "compose" => {
                        let (code, raw) = parse_code_block(parser);
                        let eval = execute_code_block(&raw, &meta, line)?;
                        ctx.last_eval = Some(eval);

                        events.extend(emit_code_block(info.to_string(), code));
                    }
                    "output" => {
                        let code = handle_output_block(parser, &ctx, &meta, line, config)?;
                        events.extend(emit_code_block("text".to_string(), code));
                    }
                    _ => events.push(event.clone()),
                }
            }
            _ => {
                events.push(event.clone());
            }
        }
    }
    Ok(events)
}

/// Parses a code block into a display and raw code
fn parse_code_block(parser: &mut Peekable<OffsetIter<'_>>) -> (String /*display*/, String /*raw*/) {
    let mut display = String::new();
    let mut raw = String::new();

    while let Some((Event::Text(text), _)) = parser.peek() {
        for line in text.lines() {
            let trimmed = line.trim_start();
            let indent_len = line.len() - trimmed.len();

            if let Some(stripped) = trimmed.strip_prefix("# ") {
                // Strip `#` but keep the original indentation
                raw.push_str(&line[..indent_len]); // leading spaces
                raw.push_str(stripped); // the rest of the line after `# `
                if !raw.ends_with('\n') {
                    raw.push('\n');
                }
                // Do not include in display
            } else {
                raw.push_str(line);
                if !raw.ends_with('\n') {
                    raw.push('\n');
                }

                display.push_str(line);
                if !display.ends_with('\n') {
                    display.push('\n');
                }
            }
        }
        parser.next();
    }

    (display, raw)
}

fn handle_output_block(
    parser: &mut Peekable<OffsetIter<'_>>,
    ctx: &BlockContext,
    meta: &BlockHeader,
    line: usize,
    config: &Config,
) -> Result<String, Error> {
    while let Some((Event::Text(_), _)) = parser.peek() {
        parser.next(); // discard any content in the code block
    }

    let eval = ctx
        .last_eval
        .as_ref()
        .ok_or("missing preceding compose block")
        .at(line)?;

    let mut out = String::new();

    for warning in &meta.expected_warnings {
        let diag = find_diag(&eval.warnings, warning, line)?;
        out.push_str(&diagnostics_to_string(
            &eval.world,
            &[],
            &[diag.clone()],
            config,
        ));
    }

    for error in &meta.expected_errors {
        let diag = find_diag(&eval.errors, error, line)?;
        out.push_str(&diagnostics_to_string(
            &eval.world,
            &[diag.clone()],
            &[],
            config,
        ));
    }

    if meta.stdout {
        out.push_str(&eval.stdout);
    }

    Ok(out)
}

fn find_diag<'a>(
    diags: &'a [SourceDiagnostic],
    code_str: &str,
    line: usize,
) -> Result<&'a SourceDiagnostic, Error> {
    let code = lookup(code_str)
        .ok_or_else(|| format!("unknown code: {code_str}"))
        .at(line)?;

    diags
        .iter()
        .find(|d| d.code == Some(code))
        .ok_or_else(|| format!("expected diagnostic code {code_str}"))
        .at(line)
}

fn emit_code_block<'a>(lang: String, code: String) -> Vec<Event<'a>> {
    vec![
        Event::Start(Tag::CodeBlock(CodeBlockKind::Fenced(lang.into()))),
        Event::Text(code.into()),
    ]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_code_block_strips_hash_lines() {
        let input = "```compose\n# let a = 1;\nlet b = a + 1;\n```";
        let mut parser = Parser::new(input).into_offset_iter().peekable();
        // consume the opening ```compose
        parser.next();

        let (display, raw) = parse_code_block(&mut parser);

        assert_eq!(display.trim(), "let b = a + 1;");
        assert_eq!(raw.trim(), "let a = 1;\nlet b = a + 1;");
    }
}
